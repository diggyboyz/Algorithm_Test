<h3>2-1</h3>
문제링크 : https://programmers.co.kr/learn/courses/30/lessons/42860?language=java

<h4>문제에 대한 이해</h4>

조이스틱을 움직여 알파벳 이름을 완성해야 한다.

알파벳은 초기에 A로만 이루어져 있으며 완성해야 하는 글자수에 따라 A의 개수도 달라진다.

조이스틱을 위로 움직이면 다음알파벳(Z에서 위로 이동하면 A), 아래로 움직이면 이전알파벳 (A에서 아래쪽으로 이동하면 Z)

왼쪽으로 이동하면 왼쪽문자(첫번째 위치에서 왼쪽으로 이동하면 마지막 문자로 커서), 오른쪽으로 이동하면 오른쪽 문자(마지막 위치에서 오른쪽으로 이동하면 첫번째 문자로 커서)

이 때 조이스틱의 조작 횟수를 최솟값으로 구해라.

<h4>입출력 규칙</h4>

알파벳은 대문자로만 이루어져 있음.

알파벳의 길이는 1이상 20이하임.

<h4>입출력 예시</h4>

name = "JEROEN" return = 56
name = "JAN" return = 23


<h4>해결 방법</h4>

count = 0으로 설정한다.

입력받은 문자열의 길이가 x이면 x의 길이만큼 A로 이루어진 문자 자료구조를 만든다.

name의 n번째 문자가 A가 아니라면 name.charAt(n) - 'A' = charDiff 연산을 통해 알파벳개수의 절반값(half='Z'-'A'+1)=(13) 이상이 나오면 그러면 알파벳개수 - charDiff 만큼 count에 더해준다.

그렇지 않다면 charDiff만큼 count에 더해준다.(위로 이동하는게 빠를것인지, 아래로 이동하는게 빠를것인지)

그렇다면 이동을 어떻게 해야할까?? (왼쪽으로 이동하는게 빠를것인지, 오른쪽으로 이동하는게 빠를것인지)

 3가지의 이동경우가 있음
 
1. 오른쪽으로 계속가는경우 BBBBBAAB

2. 왼쪽으로 계속가는경우 AAAAAAAAAAAAB            

3. 오른쪽으로 가다가 왼쪽으로가는경우 예시 문자열 ABABAAAAAABBB


            
1.연속된 A의 가장큰 덩어리를 찾음

2.덩어리의 길이와 덩어리시작의 index를 비교함.

3.index보다 덩어리의 길이가 더 크거나 같으면 해당 index에서 방향전환이 발생함

4.덩어리의 길이보다 index가 더 크면 방향전환없음





<h4>주의사항 및 시행착오</h4>

처음에 알파벳의 개수를 일일히 세려다가 아스키코드를 활용하여 ('Z' - 'A' + 1) 를 하면 알파벳의 개수를 구할 수 있을것이라고 생각함. 

+1을 해준이유는 (1,2,3)의 개수를 셀 때 3-1=2 이므로 +1을 해주어야 동일한 개수가 됨.

매 선택의 기로에서 왼쪽으로 갈지, 오른쪽으로 갈지 가장 최적의 방법을 고르고, 그 방법지 안에서 또 위로 수정할지 아래로 수정할지 가장 최적의 방법을 골라야 해결할 수 있는 문제이다.

처음에는 AAAA를 실제로 name 문자열과 같게 바꾸어주고 AAAA문자열이 name문자열과 다른동안 while문을 돌게하려 했는데  그렇게 되면 문자열 연산이 계속 발생하게 될 것 같아

실제로 "AAAAA" 문자열을 name 문자열로 바꿔줄 필요없이 name문자열을 'AAAAA" 형태로 바꿔주는 작업형식으로 answer을 count하면서 연산하면 될 것 같습니다.

<b>0번 인덱스에서 왼쪽으로 이동은 가능하지만 마지막 인덱스에서 오른쪽 이동은 가능하다는 조건이 없었음.</b>
