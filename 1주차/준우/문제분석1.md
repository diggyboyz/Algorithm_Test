<h3>1-1</h3> 문제 링크 https://www.acmicpc.net/problem/3190
  
  <h4>문제에 대한 이해</h4>
  
  - N x N 정사각 보드위에서 게임이 진행된다.
  
  - 게임은 맨위 맨좌측에서 시작을 하며 뱀의 길이는 1이며 뱀은 처음에 오른쪽을 향한다.
   
  - 뱀의 이동규칙은 매 초마다 이동을 하는데 머리가 먼저 움직이고 사과가있다면 꼬리가 움직이지 않고 사과가 없다면 꼬리가 위치한 칸을 비운다. 
    
  - 뱀은 사과를 먹으면 길이가 늘어난다.
  
  - 벽 또는 자기자신의 몸과 부딪히면 게임은 끝나게되고 끝날 때의 시간을 반환한다.
  
  <h4>입출력의 규칙</h4>
  
  - 첫째 줄에 보드의 크기N이 주어진다 ( 2<=N<=100)
  - 둘째 줄에는 사과의 개수 K가 주어진다.
  - 셋재 줄에는 사과의 위치가 주어진다.
  - 넷째 줄에는 뱀의 방향 변환 횟수 L이 주어진다 (1<=L<=100)
  - 다음 L개의 줄에는 뱀의 방향 변환 정보가 주어지고 정수X와 문자C로 이루어진다. 이는 X초가 끝난 뒤에 C(L또는D) 왼쪽(L) 오른쪽(D)로 90도 방향을 회전시킨다는 뜻이다 
  
  <h4>예제 입력</h4>
  
  6
  
  3
  
  3 4
  
  2 5
  
  5 3
  
  3
  
  3 D
  
  15 L
  
  17 D
  
  
  6x6의 보드 크기에 사과의 개수는 3개이다 사과는(3,4),(2,5),(5,3)위치에 각각 존재한다.
  
  방향 변환 정보는 3개이며 (3,D),(15,L),(17,D)로 3초가 끝난뒤에 오른쪽으로 90도, 15초가 끝난뒤에 왼쪽으로 90도, 17초가 끝난뒤에 오른쪽으로 90도 회전한다.
  
  이 때 게임은 몇 초에 끝나는가? 9초
  
  <h4>해결 방법</h4>
  
  1.우선 (N+2)x(N+2)크기의 board배열을 만드는데 이유는 테두리를 벽으로 감싸기 위해서 그래서 벽은 1으로 벽이 아닌부분은 0으로 채운다.<br>
  
  2.사과의 위치를 2로 채운다.
  
  3.게임의 시간은 0초에서 시작하며 뱀을(1,1)위치에 1으로 그리며 충돌검사를(1을 만나면 충돌)하며 충돌을 하면 게임시간 +1초값을 반환하며 종료된다 충돌하지 않았다면 게임시간을 1초 증가시키며 정해진방향(초기값 오른쪽)으로 이동시킨다.
  
  <h5>방향전환은 어떻게 시켜야 할까?</h5>
  
  방향을 나타내는 direct변수를 가지고 0은 오른쪽, 1은 아래, 2는 왼쪽, 3은 위로 하면서 D를 만나면 +1 L을 만나면 -1을 한다.
  
  direct는 4로 나머지연산을하여 4를 넘지않게 하며 0에서 -1이 될경우에는 3으로 변경해준다.
  
  
  <h5>뱀을 이동시켜야 하는데 어떻게 이동시켜야 할까?</h5>
 
  
  처음 들었던 생각은 머리부분과 꼬리부분의 좌표를 알면 해결되지 않을까 였는데 그렇게되면 이동을하면서 꼬리 앞부분으로 좌표를 당겨야하는데 1차원적으로 한방향으로 움직이는게 아니기 때문에 꼬리앞부분의 좌표를 모르기 때문에 꼬리앞부분의 좌표까지
  기억하고 있어야 한다. 
  
  그렇게 되면 결국에 꼬리앞부분의 앞부분의 좌표를 알아야하기 때문에 결국 모든부분의 좌표를 알고있어야 하고 그러면 연결리스트형태로 뱀의 몸통,머리,꼬리들이 좌표를 가지고 있어야 한다고 생각이 들었다.
  
  따라서 연결리스트 형태로 뱀을 구현한다. ArrayList로 구현도 가능할 것 같다. java 컬렉션에 대한 공부필요. LinkedList의 경우에는 ArrayList보다 삽입,삭제측면에서 이점을 가지는 LinkedList의 경우 주소만 바꾸어 주면되지만 ArrayList는 중간에 삽입해야할경우 나머지 값들을 뒤로 밀어야 한다. 하지만 탐색부분에서는 ArrayList는 무작위접근이 가능한 반면 LinkedList는 순차적접근을 해야한다.
  
  이동할 때 머리를 LinkedList를 사용하여 머리부분에 가는길의 좌표를 snake.addFirst(coord) 추가하고 꼬리부분의값을 snake.removeLast();를 사용하여 삭제해주면 된다. 이렇게되면 모든 좌표들을 연산할 필요 없어지게 되고 삽입,삭제가 빈번하게 일어남으로 arrayList보다 LinkedList가 효율적일것이라 LinkedList로 구현하기로 결정. 물론 중간에서 삽입, 삭제가 발생하지 않고 처음과 끝부분에서 발생하기 때문에 시간이 그렇게 차이가 나진 않을것이며 참조의 지역성때문에 LinkedList는 arrayList보다 느리고 연결을 위한 추가적인 메모리도 필요하지만 삽입,삭제에 효율적인 LinkedList가 좋을것이라고 판단.
  
  ~~이동할 때 연결리스트의 맨 앞부분은 방향을 기반하여 값이 바뀌게되고 뒷부분의 노드들은 앞부분의 노드들로 값이 바뀌게된다.~~
  
  또한 board배열에서 뱀의 머리부분이지나가는부분은1 꼬리부분이 지나가는부분은 0으로 값을 대체시킨다.
  
  
  <h5>사과를 마주치면 어떻게 해야할까?</h5>
  
  만약에 머리의 다음 진행방향이 사과라면 연결리스트 맨앞부분에 새로운 노드를 추가한다.
   
   <h5>주의사항</h5>
   
   머리가 먼저 움직이고 꼬리가 움직이기 때문에 머리를 움직이고 충돌검사를 바로 한 후 이상이 없으면 다음과정들을 진행한다.


<h5>어려웠던 점</h5>

BOARD[Y][X]로 값을 갱신해야 했던 점이 처음에 이해가 되지 않았음

OBJ[i] == "D" 는 되지않고 OBJ[i].EQUALS("D")만 동작이 해서 ==연산자와 EQUALS 메소드의 차이점을 알게 되었음 ( == 연산자는 주소값비교 , EQUALS메소드는 내용을 비교)

