
<h2>문제 링크</h2>
 https://www.acmicpc.net/problem/16234

<h2>문제 해석</h2>
N x N 크기의 땅이 있고 땅은 1x1개의 칸으로 나누어져 있다. (2차원 배열을 사용)



각각의 땅에는 나라가 존재하며 r행 c열에 있는 나라에는 A[r][c]명이 살고 있습니다.



인접한 나라 사이에는 국경선이 존재하며 인구를 이동시키려고 합니다.



<h3>인구 이동의 절차</h3>

- 인구 이동이 없을 때 까지 반복하면서 진행합니다. (while문 조건)



- 국경선을 공유한 두 나라의 인구 차이가 L명 이상, R명 이하라면 국경선을 하루동안 엽니다. (for 문을 통해 검사)
- 모든 나라에 대해 검사를 진행한 후, 인구 이동을 시작합니다. 

- 국경선이 열려있어서 이동 할 수 있다면, 그 나라들을 연합이라고 합니다.

- 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 됩니다. (여기서 소수점은 버립니다.) (연합을 어떻게 확인할것인가)

- 인구 이동이 이루어지고, 모든 연합은 해제되며, 모든 국경선이 닫힙니다.



이 때 인구 이동이 며칠 동안 발생하는지 구하시오.



<h2>입력</h2>
첫째 줄에 N, L, R이 주어집니다. 

둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어집니다. ( A[r][c]의 값들) 



<h2>제약조건</h2>

1<= N <= 50

1 <= L <= R <= 100

0 <= A[r][c] <=100

인구 이동이 발생하는 일수가 2,000번 보다 작거나 같은 입력만 주어진다.



<h2>출력</h2>
인구 이동이 며칠 동안 발생하는지 출력합니다.



<h2>문제의 풀이전 설계</h2>
입력값 받기

우선 입력값 N, L, R에 대해 입력을 받아야하며﻿

이중 for문 (N x N) 번 반복등 통하여 2차원 배열 A[r][c]에 인구수를 입력받습니다.

배열의 이름은 의미가 없는 A가 아니라 의미가 있는 polulation을 사용하려고 합니다.



<h3>핵심 기능</h3>

인구 이동이 발생하지 않을 때 까지 반복 ( while문 조건) - 인구이동이 이루어 지고 나면 모든 연합 해제, 국경선 닫힘

국경선을 공유하는 나라들을 확인하며 ﻿인구 차이가 L명이상 R명 이하라면 국경선을 여는 기능 (for 문을 통해 검사)

국가별 연합을 확인하는 기능

연합한 국가별로 인구수(연합의 총 인원수 / 연합의 수) 분배하는 기능





<h3>풀이하면서 고민해본점</h3>

<h4>입력은 어떻게 받는것이 효율적일까? (Sacnner vs BufferedReader)</h4>

https://junuuu.tistory.com/7?category=968252 


<h4>출력은 어떻게 하는것이 효율적일까? (System.out.println vs BufferedWriter)</h4>

추후 작성예정

 

<h4>인구 이동이 발생하지 않을 때 까지 반복 ( while문 조건)에서 조건문은 어떻게 구현할 것인가?</h4>

처음에 boolean move = False 로 선언한뒤 만약 두 국가의 인구수 차이가 L명이상 R명 이하라면 True로 설정한다.

while(move) < while문 반복조건 (move = True이면 반복하고 move = False 이면 종료한다.)

 

<h4>국경선을 공유하는 나라들을 확인하며 인구 차이가 L명이상 R명 이하라면 국경선을 여는 기능은 어떻게 구현할 것인가?</h4>

처음 생각으로는 배열을 for문으로 순회하면서 해당배열의 오른쪽과 아래를 검사하며 국경선을 열지 말지 검사 하려고 했다.

하지만 위의 방법으로 국가별 연합을 확인하는 기능을 구현하기 위해서는 추가적인 3차원 배열이 필요할 것 같았고 그 배열을 통해서 또 연합을 확인해야 하는 과정이 필요하다고 생각했다.

*3차원 배열이라고 생각한 이유는 배열의 행과열을 확인하는 2차원 배열 + 위, 오른쪽, 왼쪽, 아래의 국경선이 열려있는지 확인해주는 배열

 

따라서 3차원 배열 + 다시 연합을 확인해야 하는 과정이 너무 비효율적일것 같아서 다른 방법을 고민해보기로 했다.

국가별 연합을 확인하는 기능을 구현하기 위해서는 국경선이 연결이 되어있는 쪽으로 계속 타고 들어가야 한다고 생각해서 DFS 느낌으로 구현하면 좋을 것 같다고 생각했다.

 

<h5>이 방법을 사용한다면</h5>

배열이 방문되었는지 확인하는 2차원 배열인 visited[][]배열(초기값은 모두 False)을 만들어야 한다.

 

2중포문으로 population배열을 확인하면서 국경선을 열 수 있다면 계속 타고 들어가면서 검사를 한다. 이 때 재귀함수로 구현해야 할 수도 있으며,  방문을 한 배열은 visited배열에 True로 저장한다.

 

만약 국경선이 연결되어 있다면 연결된 수 만큼 Count를 하고 Sum에 국가의 인구수를 계속 더 하면서 연합의 총 인구수를 저장한다.

 

2중포문으로 population배열을 확인하는데 하나의 행열에서 재귀함수가 종료되면 (연합의 총 인구수 / 연합의 수)를 계산한 값을 모든 연합에 넣어준다.

 

<h5>재귀함수는 어떻게 구현하면 좋을까요?</h5>

이때 배열이 -1, N에 접근하지 않도록 if문을 통해 제어한다.

visited[i][j] == false 이며 두 국가의 인구수 차이가 L과 R사이 있다면 국경이 열리도록 합니다.

이 방법을 위, 아래, 오른쪽, 왼쪽을 모두 검사하면서 재귀적으로 호출합니다.

 

이때 재귀함수를 호출하면서 이전의 행열들을 저장해놓는다면 그 행열들을 저장해놓은 배열을 연합이라고 볼 수 있으므로 배열을 기준으로 (연합의 총 인구수 / 연합의 수)를 계산한 값을 넣어준다.

 

이 방법을 토대로 2중포문으로 population배열을 확인하면 2차원 배열인 visited[][]배열이 모두 True가 되면 반복문을 종료하고 다시 인구이동이 일어나는지 검사하게 된다

 

반복문이 종료되게 되면 국경선 공유 확인, 국가별 연합 확인, 연합한 국가별로 인구수 분배하는 기능들이 모두 해결된다.

 
 
<h5>모든 나라에 대한 검사를 진행한 후 인구 이동을 시켜야 하는데 한 연합에 대해서 이동을 진행하고 다른 연합이 연결된 것을 찾아 이동을 진행한다면 문제가 없을까요?</h5>
 
visited배열을 통해 방문되었는지 확인하기 때문에 겹칠일이 없어 문제가 되지 않음
 
 
<h4>어떻게 하면 함수화를 깔끔하게 하고 가독성을 높일 수 있을까?</h4>

최대한 한가지 기능만 구현하게 하고 함수가 길어지지 않도록 노력하였으며 의미있는 함수명, 변수이름을 부여함.








